<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lecture 2: Divide and Conquer</title>
      <link href="/Lecture-2-Divide-and-Conquer/"/>
      <url>/Lecture-2-Divide-and-Conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="Paradigm"><a href="#Paradigm" class="headerlink" title="Paradigm"></a>Paradigm</h1><p>对于分而治之问题的时间复杂度计算：对于数据规模为$n$的问题，如果分解成规模为$\frac{n}{b}$的子问题，且$a\ge 1,b &gt; 1$，那么有</p><script type="math/tex; mode=display">T(n)=a T\left(\frac{n}{b}\right)+[work\ for\ merge]</script><p>我们会在下一节课通过<em>Master Theorithm</em>得到具体的时间复杂度</p><h1 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h1><p>在平面中给定$n$个点，假定任意两个点的x坐标与y坐标都不相同，且没有三个点出现在同一直线上。</p><script type="math/tex; mode=display">S = \{(x_i, y_i)|i = 1, 2,...,n\}</script><p><strong>Convex Hull (CH(S))</strong>: 包含$S$中所有点的最小多边形</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.22glmow0h8jk.png" alt="convex hull"></p><p>CH(S)可以通过一个双向链表由边界上的点序列按顺时针顺序表示：</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.2jhmuiodvm4.webp" alt="dot sequence" style="zoom:67%;" /></p><h2 id="Brute-force-for-Convex-Hull"><a href="#Brute-force-for-Convex-Hull" class="headerlink" title="Brute force for Convex Hull"></a>Brute force for Convex Hull</h2><p>直接遍历每一条线段是否为CH(S)的一条边：</p><ul><li>若其它所有点都在这条边的一侧，那么这条线段属于CH(S)</li><li>否则，则不是CH(S)的一条边</li></ul><p>$O(n^2)$ edges, $O(n)$ tests ⇒ $O(n^3)$ complexity （<em>怎样优化？</em>）</p><h2 id="Divide-and-Conquer-Convex-Hull"><a href="#Divide-and-Conquer-Convex-Hull" class="headerlink" title="Divide and Conquer Convex Hull"></a>Divide and Conquer Convex Hull</h2><p>Sort points by x coord (once and for all, $O(nlogn)$)</p><p>For input set <em>S</em> of points:</p><ul><li>Divide into left half <em>A</em> and right half <em>B</em> by x coords</li><li>Compute CH(<em>A</em>) and CH(<em>B</em>)</li><li>Combine CH’s of two halves (merge step)</li></ul><h2 id="How-to-Merge"><a href="#How-to-Merge" class="headerlink" title="How to Merge?"></a>How to Merge?</h2><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.5w6r7hdiba80.webp" alt="merge example"></p><h3 id="Finding-Tangents"><a href="#Finding-Tangents" class="headerlink" title="Finding Tangents"></a>Finding Tangents</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1, j=1</span><br><span class="line">while (y(i, j + 1) &gt; y(i, j) or y(i − 1, j) &gt; y(i, j))</span><br><span class="line">if (y(i, j + 1) &gt; y(i, j)) -&gt; move right finger clockwise</span><br><span class="line">j = j + 1(mod q)</span><br><span class="line">else</span><br><span class="line">i = i − 1(mod p) -&gt; move left finger anti-clockwise</span><br><span class="line">return (a_i, b_j) as upper tangent</span><br></pre></td></tr></table></figure><h1 id="Median-Finding"><a href="#Median-Finding" class="headerlink" title="Median Finding"></a>Median Finding</h1>]]></content>
      
      
      <categories>
          
          <category> 6.046J-2015Sping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> MIT OCW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数理逻辑读书笔记：归纳与递归</title>
      <link href="/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/"/>
      <url>/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/logic.pdf" style='width:100%;height:900px'></iframe>]]></content>
      
      
      <categories>
          
          <category> 数理逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A Mathematical Introduction to Logic </tag>
            
            <tag> 坐牢 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lecture 1: Introduction</title>
      <link href="/Lecture-1-Introduction/"/>
      <url>/Lecture-1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="P-amp-NP"><a href="#P-amp-NP" class="headerlink" title="P &amp; NP"></a>P &amp; NP</h1><ul><li><p><strong>P</strong>: class of problems solvable in polynomial time. $O(n^k)$ for some constant $k$. </p><p>Shortest paths in a graph.</p></li><li><p><strong>NP</strong>: class of problems verifiable in polynomial time. </p><p>Verifying a cycle is hamiltonian.</p></li><li><p><strong>NP-complete</strong>: problem is in NP and is as hard as any problem in NP.</p><p>如果NPC问题可在多项式时间内被解决，那么所有的NP问题都可以在多项式时间内被解决</p></li></ul><h1 id="Interval-Scheduling-区间调度问题"><a href="#Interval-Scheduling-区间调度问题" class="headerlink" title="Interval Scheduling / 区间调度问题"></a>Interval Scheduling / 区间调度问题</h1><p>Requests $1,2, . . . , n$, single resource</p><p>$s(i)$ start time, $f(i)$ finish time, $s(i) &lt; f(i)$ (start time must be less than finish time for a request)</p><p>Two requests $i$ and $j$ are compatible if they don’t overlap, i.e., $f(i) \le s(j)$ or $f(j) \le s(i)$.</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/intervalScheduling.5vmv6e5bjes0.png" alt="intervalScheduling" style="zoom:70%;" /></p><p><strong>Goal</strong>: Select a compatible subset of requests of <strong>maximum size</strong>.</p><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。</p><ol><li>使用某种方法选择一个request $i$.</li><li>拒绝request中冲突的部分</li><li>重复这一步骤直到所有的request被处理</li></ol><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p><strong>Claim 1.</strong> Greedy algorithm outputs a list of intervals</p><script type="math/tex; mode=display">< s(i_1), f(i_1)>, < s(i_2), f(i_2)>, . . . , < s(i_k), f(i_k) ></script><p>such that</p><script type="math/tex; mode=display">s\left(i_{1}\right)<f\left(i_{1}\right) \leq s\left(i_{2}\right)<f\left(i_{2}\right) \leq \ldots \leq s\left(i_{k}\right)<f\left(i_{k}\right)</script><p><strong>Claim 2.</strong> Given list of intervals $L$, greedy algorithm with <strong>earliest finish time</strong> produces $k^<em>$ intervals, where $k^</em>$ is optimal.</p><p>证明可使用数学归纳法，从$k^<em>=1$的base case归纳，可以得到$k^</em>$一直是最优的序列，详细过程略。</p><h1 id="Weighted-Interval-Scheduling"><a href="#Weighted-Interval-Scheduling" class="headerlink" title="Weighted Interval Scheduling"></a>Weighted Interval Scheduling</h1><p>Each request $i$ has weight $w(i)$. Schedule subset of requests that are non-overlapping with <strong>maximum weight</strong>.</p><p>我们不难发现，在此时贪心算法是失效的，因此我们选择动态规划解决。</p><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p><strong>动态规划</strong>（DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>我们这样定义Weighted Interval Scheduling的子问题：</p><script type="math/tex; mode=display">R^{x}=\{j \in R \mid s(j) \geq x\}</script><p>其中，$R$是所有request的集合，如果我们令$x=f(i)$，那么$R^{x}$为集合$R$中起始时间晚于request $i$的request，这样我们需要解决的总子问题数$n=|R|$且只需要计算并记录一次。</p><p>当我们选择request $i$作为序列的起始时，那么剩余的request集合为$R^{f(i)}$，不难注意到有些request与request $i$是协调的，但它仍然不会出现在$R^{f(i)}$中，即我们在按序遍历所有的子问题：</p><script type="math/tex; mode=display">\operatorname{opt}(R)=\max _{1 \leq i \leq n}\left(w(i)+\operatorname{opt}\left(R^{f(i)}\right)\right)</script><p>此时，时间复杂度为$O(n^2)$，这是由于解决每个子问题的时间复杂度为$O(n)$.</p>]]></content>
      
      
      <categories>
          
          <category> 6.046J-2015Sping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> MIT OCW </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
