<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Lecture 2: Divide and Conquer</title>
      <link href="/Lecture-2-Divide-and-Conquer/"/>
      <url>/Lecture-2-Divide-and-Conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="Paradigm"><a href="#Paradigm" class="headerlink" title="Paradigm"></a>Paradigm</h1><p>对于分而治之问题的时间复杂度计算：对于数据规模为$n$的问题，如果分解成规模为$\frac{n}{b}$的子问题，且$a\ge 1,b &gt; 1$，那么有</p><script type="math/tex; mode=display">T(n)=a T\left(\frac{n}{b}\right)+[work\ for\ merge]</script><p>我们会在下一节课通过<em>Master Theorem</em>得到具体的时间复杂度</p><h1 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h1><p>在平面中给定$n$个点，假定任意两个点的x坐标与y坐标都不相同，且没有三个点出现在同一直线上。</p><script type="math/tex; mode=display">S = \{(x_i, y_i)|i = 1, 2,...,n\}</script><p><strong>Convex Hull (CH(S))</strong>: 包含$S$中所有点的最小多边形</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.22glmow0h8jk.png" alt="convex hull"></p><p>CH(S)可以通过一个双向链表由边界上的点序列按顺时针顺序表示：</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.2jhmuiodvm4.webp" alt="dot sequence" style="zoom:67%;" /></p><h2 id="Brute-force-for-Convex-Hull"><a href="#Brute-force-for-Convex-Hull" class="headerlink" title="Brute force for Convex Hull"></a>Brute force for Convex Hull</h2><p>直接遍历每一条线段是否为CH(S)的一条边：</p><ul><li>若其它所有点都在这条边的一侧，那么这条线段属于CH(S)</li><li>否则，则不是CH(S)的一条边</li></ul><p>$O(n^2)$ edges, $O(n)$ tests ⇒ $O(n^3)$ complexity （<em>怎样优化？</em>）</p><h2 id="Divide-and-Conquer-Convex-Hull"><a href="#Divide-and-Conquer-Convex-Hull" class="headerlink" title="Divide and Conquer Convex Hull"></a>Divide and Conquer Convex Hull</h2><p>Sort points by x coord (once and for all, $O(nlogn)$)</p><p>For input set <em>S</em> of points:</p><ul><li>Divide into left half <em>A</em> and right half <em>B</em> by x coords</li><li>Compute CH(<em>A</em>) and CH(<em>B</em>)</li><li>Combine CH’s of two halves (merge step)</li></ul><h2 id="How-to-Merge"><a href="#How-to-Merge" class="headerlink" title="How to Merge?"></a>How to Merge?</h2><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.5w6r7hdiba80.webp" alt="merge example"></p><ul><li>找到upper tangent $(a_i,b_j)$，在这里$(a_4,b_2)$即为U.T.</li><li>找到lower tangent $(a_k,b_m)$，在这里$(a_3,b_3)$即为L.T.</li><li>首先连接$(a_i,b_j)$，按照顺时针遍历B的链表直到$b_m$，连接$(a_k,b_m)$，同样的，以顺时针遍历直到A的链表直到$a_i$，这样我们就得到了新的Covex Hull</li></ul><h3 id="Finding-Tangents"><a href="#Finding-Tangents" class="headerlink" title="Finding Tangents"></a>Finding Tangents</h3><p>Assume $a_i$ maximizes x within CH(<em>A</em>) $(a_1, a_2,…,a_p)$. $b_1$ minimizes x within CH(<em>B</em>) $(b_1, b_2,…,b_q)$</p><p>$L$ is the vertical line separating <em>A</em> and <em>B</em>. Define $y(i, j)$ as y-coordinate of intersection between <em>L</em> and segment $(a_i, b_j)$</p><p><strong>Claim</strong>: $(a_i,b_j)$ is uppertangent iff it maximizes $y(i, j)$. If $y(i, j)$ is not maximum, there will be points on both sides of $(a_i, b_j)$ and it cannot be a tangent</p><p><strong>Algorithm</strong>: Obvious $O(n^2)$ algorithm looks at all $a_i, b_j$ pairs. $T(n)=2T(n/2)+ Θ(n^2) = Θ(n^2)$</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1, j=1</span><br><span class="line">while (y(i, j + 1) &gt; y(i, j) or y(i − 1, j) &gt; y(i, j))</span><br><span class="line">if (y(i, j + 1) &gt; y(i, j)) -&gt; move right finger clockwise</span><br><span class="line">j = j + 1(mod q)</span><br><span class="line">else</span><br><span class="line">i = i − 1(mod p) -&gt; move left finger anti-clockwise</span><br><span class="line">return (a_i, b_j) as upper tangent</span><br></pre></td></tr></table></figure><h1 id="Median-Finding"><a href="#Median-Finding" class="headerlink" title="Median Finding"></a>Median Finding</h1><p>给定一个有n个数的集合，定义<em>rank(x)</em>为集合中小于等于x的数的数量，找到集合中第$\left\lfloor\frac{n+1}{2}\right\rfloor$大的数(lower median)与第$\left\lceil\frac{n+1}{2}\right\rceil$大的数(upper median). 通过排序来解决这样一个问题是显然的，但时间复杂度会达到$\Theta(n \log n)$，如何优化？</p><h2 id="Select-S-i"><a href="#Select-S-i" class="headerlink" title="Select (S,i)"></a>Select (S,i)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pick x ∈ S cleverly</span><br><span class="line">Compute k = rank(x)</span><br><span class="line">B = &#123;y ∈ S|y &lt; x&#125;</span><br><span class="line">C = &#123;y ∈ S|y &gt; x&#125;</span><br><span class="line">if k = i</span><br><span class="line">return x</span><br><span class="line">else if k&gt;i</span><br><span class="line">return Select(B, i)</span><br><span class="line">else if k&lt;i</span><br><span class="line">return Select(C, i − k)</span><br></pre></td></tr></table></figure><h2 id="Picking-x-Cleverly"><a href="#Picking-x-Cleverly" class="headerlink" title="Picking x Cleverly"></a>Picking x Cleverly</h2><p>我们需要合理的选取x以防止极端情况出现：</p><ul><li>将集合S分成大小为5的列（$\left\lceil\frac{n}{5}\right\rceil$列）</li><li>对每一列进行排序，时间复杂度为线性</li><li>找到每一列中位数的中位数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.4r66tofk6fw0.webp" alt="visual"></p><h3 id="有多少个数是保证大于x的？"><a href="#有多少个数是保证大于x的？" class="headerlink" title="有多少个数是保证大于x的？"></a>有多少个数是保证大于x的？</h3><p>至少一半的$\left\lceil\frac{n}{5}\right\rceil$列都会保证至少有3个数是大于x的，除了x所在的列与少于5个数的列，因此至少有$3(\left\lceil\frac{n}{10}\right\rceil-2)$个数大于x，于是有：</p><script type="math/tex; mode=display">    T(n)=\left\{\begin{array}{ll}O(1), & \text { for } n \leq 140 \\ T\left(\left\lceil\frac{n}{5}\right\rceil\right)+T\left(\frac{7 n}{10}+6\right), \Theta(n), & \text { for } n>140\end{array}\right.</script><p><em>证明递归复杂度过程略</em></p>]]></content>
      
      
      <categories>
          
          <category> 6.046J-2015Sping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> MIT OCW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数理逻辑读书笔记：归纳与递归</title>
      <link href="/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/"/>
      <url>/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/logic.pdf" style='width:100%;height:900px'></iframe>]]></content>
      
      
      <categories>
          
          <category> 数理逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A Mathematical Introduction to Logic </tag>
            
            <tag> 坐牢 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lecture 1: Introduction</title>
      <link href="/Lecture-1-Introduction/"/>
      <url>/Lecture-1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="P-amp-NP"><a href="#P-amp-NP" class="headerlink" title="P &amp; NP"></a>P &amp; NP</h1><ul><li><p><strong>P</strong>: class of problems solvable in polynomial time. $O(n^k)$ for some constant $k$. </p><p>Shortest paths in a graph.</p></li><li><p><strong>NP</strong>: class of problems verifiable in polynomial time. </p><p>Verifying a cycle is hamiltonian.</p></li><li><p><strong>NP-complete</strong>: problem is in NP and is as hard as any problem in NP.</p><p>如果NPC问题可在多项式时间内被解决，那么所有的NP问题都可以在多项式时间内被解决</p></li></ul><h1 id="Interval-Scheduling-区间调度问题"><a href="#Interval-Scheduling-区间调度问题" class="headerlink" title="Interval Scheduling / 区间调度问题"></a>Interval Scheduling / 区间调度问题</h1><p>Requests $1,2, . . . , n$, single resource</p><p>$s(i)$ start time, $f(i)$ finish time, $s(i) &lt; f(i)$ (start time must be less than finish time for a request)</p><p>Two requests $i$ and $j$ are compatible if they don’t overlap, i.e., $f(i) \le s(j)$ or $f(j) \le s(i)$.</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/intervalScheduling.5vmv6e5bjes0.png" alt="intervalScheduling" style="zoom:70%;" /></p><p><strong>Goal</strong>: Select a compatible subset of requests of <strong>maximum size</strong>.</p><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。</p><ol><li>使用某种方法选择一个request $i$.</li><li>拒绝request中冲突的部分</li><li>重复这一步骤直到所有的request被处理</li></ol><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p><strong>Claim 1.</strong> Greedy algorithm outputs a list of intervals</p><script type="math/tex; mode=display">< s(i_1), f(i_1)>, < s(i_2), f(i_2)>, . . . , < s(i_k), f(i_k) ></script><p>such that</p><script type="math/tex; mode=display">s\left(i_{1}\right)<f\left(i_{1}\right) \leq s\left(i_{2}\right)<f\left(i_{2}\right) \leq \ldots \leq s\left(i_{k}\right)<f\left(i_{k}\right)</script><p><strong>Claim 2.</strong> Given list of intervals $L$, greedy algorithm with <strong>earliest finish time</strong> produces $k^<em>$ intervals, where $k^</em>$ is optimal.</p><p>证明可使用数学归纳法，从$k^<em>=1$的base case归纳，可以得到$k^</em>$一直是最优的序列，详细过程略。</p><h1 id="Weighted-Interval-Scheduling"><a href="#Weighted-Interval-Scheduling" class="headerlink" title="Weighted Interval Scheduling"></a>Weighted Interval Scheduling</h1><p>Each request $i$ has weight $w(i)$. Schedule subset of requests that are non-overlapping with <strong>maximum weight</strong>.</p><p>我们不难发现，在此时贪心算法是失效的，因此我们选择动态规划解决。</p><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p><strong>动态规划</strong>（DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>我们这样定义Weighted Interval Scheduling的子问题：</p><script type="math/tex; mode=display">R^{x}=\{j \in R \mid s(j) \geq x\}</script><p>其中，$R$是所有request的集合，如果我们令$x=f(i)$，那么$R^{x}$为集合$R$中起始时间晚于request $i$的request，这样我们需要解决的总子问题数$n=|R|$且只需要计算并记录一次。</p><p>当我们选择request $i$作为序列的起始时，那么剩余的request集合为$R^{f(i)}$，不难注意到有些request与request $i$是协调的，但它仍然不会出现在$R^{f(i)}$中，即我们在按序遍历所有的子问题：</p><script type="math/tex; mode=display">\operatorname{opt}(R)=\max _{1 \leq i \leq n}\left(w(i)+\operatorname{opt}\left(R^{f(i)}\right)\right)</script><p>此时，时间复杂度为$O(n^2)$，这是由于解决每个子问题的时间复杂度为$O(n)$.</p>]]></content>
      
      
      <categories>
          
          <category> 6.046J-2015Sping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> MIT OCW </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
