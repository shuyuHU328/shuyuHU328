<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JUC学习笔记</title>
      <link href="/JUC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/JUC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>从JDK1.5开始，Java提供了<code>java.util.concurrent</code>包，在此包中增加了在并发编程中很常用的工具类，并在JDK21中加入了协程（Virtual Thread）。多线程并发作为Java中的重要内容，本文希望从JUC出发，整理相关内容，学习并发编程。</p><h1 id="Java内存模型-Java-Memory-Model"><a href="#Java内存模型-Java-Memory-Model" class="headerlink" title="Java内存模型 / Java Memory Model"></a>Java内存模型 / Java Memory Model</h1><blockquote><p>JMM规定所有变量都存储在主内存中，每条线程还有自己的工作内存。线程的工作内存中保存了被线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的数据。不同线程之间也无法直接访问对方的工作内存中的变量，线程间变量值的传递需要通过主内存来完成。</p></blockquote><p>每条线程都有自己的工作空间，而共享变量存储在共享内存中。线程在运行时会首先将共享内存中的数据读取到自己的工作内存，即在线程的工作内存中复制了一个共享变量的副本，然后对其进行计算，计算完成后线程会将自己工作内存中的这个共享变量副本同步回主内存。线程、工作内存、与主内存的关系如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.4z98ywzthdc0.png" alt=""></p><h1 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h1><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p><code>volatile</code>变量有两大作用：</p><ol><li>保证可见性：指当一个线程修改了共享变量后，另外的线程能立即感知这个变量被修改。</li><li>保证有序性：指程序按照代码的先后顺序执行。有时候为了优化性能，编译器会对字节码指令进行重排序，但是能保证重排序后的执行结果与重排序之前是一致的。</li></ol><h3 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h3><p>通过例子来说明：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) ; <span class="comment">// 如果ready为false，则死循环</span></span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread is end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MyThread</span>().start();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        ready = <span class="literal">true</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;ready = &quot;</span> + ready);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;main thread is end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码中定义了一个boolean类型的成员变量<code>ready</code>,其默认值为false。在<code>MyThread</code>线程中判断如果<code>ready</code>为false时则进行死循环。接下来在<code>main</code>方法中开启<code>MyThread</code>线程，并在睡眠1s后将<code>ready</code>修改为true。正常情况下<code>ready</code>修改为true后<code>MyThread</code>线程中的死循环则会停止，并打印”MyThread is end”。但实际上的运行结果为：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MyThread is running...</span><br><span class="line">ready = <span class="literal">true</span></span><br><span class="line">main thread is end.</span><br></pre></td></tr></table></figure><p>可以看见当<code>ready</code>被修改为true后，<code>MyThread</code>线程依然未结束。通过这一例子也证实了<code>MyThread</code>线程中的<code>ready</code>副本并没有得到及时的更新。</p><p>那么接下来我们将成员变量<code>ready</code>使用<code>volatile</code>关键字修饰：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VolatileDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> ready;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread is running...&quot;</span>);</span><br><span class="line">            <span class="keyword">while</span> (!ready) ; <span class="comment">// 如果ready为false，则死循环</span></span><br><span class="line">            System.out.println(<span class="string">&quot;MyThread is end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再运行看打印日志：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MyThread is running...</span><br><span class="line">MyThread is end</span><br><span class="line">ready = <span class="literal">true</span></span><br><span class="line">main thread is end.</span><br></pre></td></tr></table></figure><p>当在主线程中修改了<code>ready</code>为true后，<code>MyThread</code>线程立即感知了<code>ready</code>的变化，并结束了死循环，从这个例子中也可以看出volatile确实能有效的保证多个线程共享变量的可见性。</p><h3 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h3><p><code>volatile</code>保证有序性在开发中有一个很常见的例子，即双重锁校验的<strong>单例模式</strong>下需要使用<code>volatile</code>关键字来禁止指令重排序。我们来看代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DoubleCheckLock</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> DoubleCheckLock instance;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DoubleCheckLock</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckLock <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//第一次检测</span></span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckLock.class)&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>)&#123;</span><br><span class="line">                    <span class="comment">//多线程环境下可能会出现问题的地方</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DoubleCheckLock</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果上述代码中没有给<code>instance</code>加上<code>volatile</code>关键字会怎么呢？</p><p>首先我们应该清楚<code>instance = new DoubleCheckLock();</code>这一操作并不是一个原子操作，实例化对象的字节指令可以分为如下三步：</p><ol><li>分配对象内存：memory = allocate();</li><li>初始化对象：instance(memory);</li><li>instance指向刚分配的内存地址：instance = memory;</li></ol><p>而由于编译器的指令重排序，以上指令可能会出现以下顺序：</p><ol><li>分配对象内存：memory = allocate();</li><li>instance指向刚分配的内存地址：instance = memory;</li><li>初始化对象：instance(memory);</li></ol><p>以优化后的字节码指令来看双重锁校验的代码是否有问题呢？不难发现，如果线程A第一次调用单例方法，在该线程的时间片轮转结束后执行到了优化后的第二个指令，即<code>instance</code>被赋值，但是还未被分配初始化对象。此时，线程B抢到了CPU时间片，同时调用了<code>getInstance</code>方法，第一次校验就发现<code>instance</code>不为null，遂将其返回。在得到这个单例后调用单例的方法，此时必定出现空指针异常。因此，可见指令重排序在多线程并发的情况下是会出现问题的。此时，我们便可以通过<code>volatile</code>关键字来禁止编译器的优化，从而避免空指针的出现。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p><code>synchronized</code> 是 Java 中用于实现线程同步的关键字，它提供了一种独占锁的机制，用于确保多个线程之间的互斥访问共享资源。</p><p><code>synchronized</code>可以用来修饰实例方法和静态方法，也可以用来修饰代码块，值的注意的是<code>synchronized</code>是一个<strong>对象锁</strong>，因此，无论使用哪一种方法，synchronized都需要有一个锁对象。</p><h3 id="修饰实例方法"><a href="#修饰实例方法" class="headerlink" title="修饰实例方法"></a>修饰实例方法</h3><p><code>synchronized</code>修饰实例方法只需要在方法上加上<code>synchronized</code>关键字即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">       i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>synchronized</code>加锁的对象就是这个方法<strong>所在实例的本身</strong>。</p><h3 id="修饰静态方法"><a href="#修饰静态方法" class="headerlink" title="修饰静态方法"></a>修饰静态方法</h3><p><code>synchronized</code>修饰静态方法的使用与实例方法并无差别，在静态方法上加上<code>synchronized</code>关键字即可</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">       i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>synchronized</code>加锁的对象为当前静态方法<strong>所在类的Class对象</strong>。</p><h3 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h3><p>synchronized修饰代码块需要传入一个对象。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，此时synchronized加锁对象即为传入的这个对象实例。</p><h3 id="synchronized锁优化"><a href="#synchronized锁优化" class="headerlink" title="synchronized锁优化"></a>synchronized锁优化</h3><p>为了解决<code>synchronized</code>效率低下，在JDK1.6中引入了偏向锁和轻量级锁来优化<code>synchronized</code>。此时的synchronized一共存在四个状态：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁着锁竞争激烈程度，锁的状态会出现一个升级的过程，即可以从偏向锁升级到轻量级锁，再升级到重量级锁。锁升级的过程是单向不可逆的，即一旦升级为重量级锁就不会再出现降级的情况。</p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p><code>ReentrantLock</code>是一种显式锁，需要我们手动编写加锁和释放锁的代码，下面我们来看下<code>ReentrantLock</code>的使用方法。</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line">    <span class="comment">// 实例化一个非公平锁，构造方法的参数为true表示公平锁，false为非公平锁。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 拿锁，如果拿不到会一直等待</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 再次尝试拿锁(可重入)，拿锁最多等待100毫秒</span></span><br><span class="line">            <span class="keyword">if</span> (lock.tryLock(<span class="number">100</span>, TimeUnit.MILLISECONDS))</span><br><span class="line">                i++;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 释放锁</span></span><br><span class="line">            lock.unlock(); </span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中<code>lock.lock()</code>会进行拿锁操作，如果拿不到锁则会一直等待。如果拿到锁之后则会执行try代码块中的代码。接下来在try代码块中又通过<code>tryLock(100, TimeUnit.MILLISECONDS)</code>方法尝试再次拿锁，此时，拿锁最多会等待100毫秒，如果在100毫秒内能获得锁，则<code>tryLock</code>方法返回true，拿锁成功，执行<code>i++</code>操作，如果返回false，获取锁失败，<code>i++</code>不会被执行。（因为第一次线程已经拿到锁了，由于<code>ReentrantLock</code>是可重入，因此，第二次必定能拿到锁。另外，<strong>要注意被<code>ReentrantLock</code>加锁区域必须用try代码块包裹，且释放锁需要在finally中来避免死锁</strong>。执行几次加锁，就需要几次释放锁。</p><h2 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h2><blockquote><p><strong>公平锁</strong>是指多个线程按照申请锁的顺序来获取锁，线程直接进入同步队列中排队，队列中最先到的线程先获得锁。<strong>非公平锁</strong>是多个线程加锁时每个线程都会先去尝试获取锁，如果刚好获取到锁，那么线程无需等待，直接执行，如果获取不到锁才会被加入同步队列的队尾等待执行。</p></blockquote><p>公平锁和非公平锁各有优缺点，适用于不同的场景：</p><ol><li>公平锁的优点在于各个线程平等，每个线程等待一段时间后，都有执行的机会；而它的缺点相较于非公平锁整体执行速度更慢，吞吐量更低。同步队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。</li><li>非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程；它的缺点也比较明显，即队列中等待的线程可能一直或者长时间获取不到锁。</li></ol><h2 id="可重入锁与非可重入锁"><a href="#可重入锁与非可重入锁" class="headerlink" title="可重入锁与非可重入锁"></a>可重入锁与非可重入锁</h2><blockquote><p><strong>可重入锁</strong>又名递归锁，是指同一个线程在获取外层同步方法锁的时候，再进入该线程的内层同步方法会自动获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。<strong>非可重入锁</strong>与可重入锁是对立的关系，即一个线程在获取到外层同步方法锁后，再进入该方法的内层同步方法无法获取到锁，即使锁是同一个对象。</p></blockquote><p><code>synchronized</code>与<code>ReentrantLock</code>都属于可重入锁。可重入锁可以有效避免死锁的产生。</p><h2 id="AbstractQueuedSynchronizer"><a href="#AbstractQueuedSynchronizer" class="headerlink" title="AbstractQueuedSynchronizer"></a>AbstractQueuedSynchronizer</h2><p><code>ReentrantLock</code>中的几个核心方法的实现都是调用了<code>Sync</code>中的相关方法，而<code>Sync</code>的主要逻辑在父类<code>AbstractQueuedSynchronizer</code>中实现。（待补充）</p><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><p>CAS是Compare And Swap的简称，即比较并交换的意思。CAS是一种无锁算法，其算法思想如下：</p><blockquote><p>CAS的函数公式：compareAndSwap(V,E,N)； 其中V表示要更新的变量，E表示预期值，N表示期望更新的值。调用compareAndSwap函数来更新变量V，如果V的值等于期望值E，那么将其更新为N，如果V的值不等于期望值E，则说明有其它线程跟新了这个变量，此时不会执行更新操作，而是重新读取该变量的值再次尝试调用compareAndSwap来更新。</p></blockquote><p>可见CAS其实存在一个循环的过程，如果有多个线程在同时修改这一个变量V，在修改之前会先拿到这个变量的值，再和变量对比看是否相等，如果相等，则说明没有其它线程修改这个变量，自己更新变量即可。如果发现要修改的变量和期望值不一样，则说明再读取变量V的值后，有其它线程对变量V做了修改，那么，放弃本次更新，重新读变量V的值，并再次尝试修改，直到修改成功为止，这个循环过程一般也称作<strong>自旋</strong>。</p><h2 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h2><p>虽然通过CAS可以实现无锁同步，但是CAS也有其局限性和问题所在。</p><ol><li><p>只能保证一个共享变量的原子性：CAS不像synchronized和RetranLock一样可以保证一段代码和多个变量的同步。对于多个共享变量操作是CAS是无法保证的，这时候必须使用枷锁来是实现。</p></li><li><p>存在性能开销问题：由于CAS是一个自旋操作，如果长时间的CAS不成功会给CPU带来很大的开销。</p></li><li><p>ABA问题：因为CAS是通过检查值有没有发生改变来保证原子性的，假若一个变量V的值为A，线程1和线程2同时都读取到了这个变量的值A，此时线程1将V的值改为了B，然后又改回了A，期间线程2一直没有抢到CPU时间片。知道线程1将V的值改回A后线程2才得到执行。那么此时，线程2并不知道V的值曾经改变过。这个问题就被成为<strong>ABA问题</strong>。</p><p>ABA问题的解决其实也容易处理，即添加一个版本号，更次更新值同时也更新版本号即可，<code>AtomicStampedReference</code>就是用来解决ABA问题的。</p></li></ol><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://juejin.cn/post/6967739352784830494#heading-7">这一次，彻底搞懂Java内存模型与volatile关键字（系列）</a></li><li><a href="https://developer.aliyun.com/article/1290951">JDK21要来了，协程可以给Java带来什么</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发编程 </tag>
            
            <tag> JDK21 </tag>
            
            <tag> 拾遗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lecture 2: Divide and Conquer</title>
      <link href="/Lecture-2-Divide-and-Conquer/"/>
      <url>/Lecture-2-Divide-and-Conquer/</url>
      
        <content type="html"><![CDATA[<h1 id="Paradigm"><a href="#Paradigm" class="headerlink" title="Paradigm"></a>Paradigm</h1><p>对于分而治之问题的时间复杂度计算：对于数据规模为$n$的问题，如果分解成规模为$\frac{n}{b}$的子问题，且$a\ge 1,b &gt; 1$，那么有</p><script type="math/tex; mode=display">T(n)=a T\left(\frac{n}{b}\right)+[work\ for\ merge]</script><p>我们会在下一节课通过<em>Master Theorem</em>得到具体的时间复杂度</p><h1 id="Convex-Hull"><a href="#Convex-Hull" class="headerlink" title="Convex Hull"></a>Convex Hull</h1><p>在平面中给定$n$个点，假定任意两个点的x坐标与y坐标都不相同，且没有三个点出现在同一直线上。</p><script type="math/tex; mode=display">S = \{(x_i, y_i)|i = 1, 2,...,n\}</script><p><strong>Convex Hull (CH(S))</strong>: 包含$S$中所有点的最小多边形</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.22glmow0h8jk.png" alt="convex hull"></p><p>CH(S)可以通过一个双向链表由边界上的点序列按顺时针顺序表示：</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.2jhmuiodvm4.webp" alt="dot sequence" style="zoom:67%;" /></p><h2 id="Brute-force-for-Convex-Hull"><a href="#Brute-force-for-Convex-Hull" class="headerlink" title="Brute force for Convex Hull"></a>Brute force for Convex Hull</h2><p>直接遍历每一条线段是否为CH(S)的一条边：</p><ul><li>若其它所有点都在这条边的一侧，那么这条线段属于CH(S)</li><li>否则，则不是CH(S)的一条边</li></ul><p>$O(n^2)$ edges, $O(n)$ tests ⇒ $O(n^3)$ complexity （<em>怎样优化？</em>）</p><h2 id="Divide-and-Conquer-Convex-Hull"><a href="#Divide-and-Conquer-Convex-Hull" class="headerlink" title="Divide and Conquer Convex Hull"></a>Divide and Conquer Convex Hull</h2><p>Sort points by x coord (once and for all, $O(nlogn)$)</p><p>For input set <em>S</em> of points:</p><ul><li>Divide into left half <em>A</em> and right half <em>B</em> by x coords</li><li>Compute CH(<em>A</em>) and CH(<em>B</em>)</li><li>Combine CH’s of two halves (merge step)</li></ul><h2 id="How-to-Merge"><a href="#How-to-Merge" class="headerlink" title="How to Merge?"></a>How to Merge?</h2><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.5w6r7hdiba80.webp" alt="merge example"></p><ul><li>找到upper tangent $(a_i,b_j)$，在这里$(a_4,b_2)$即为U.T.</li><li>找到lower tangent $(a_k,b_m)$，在这里$(a_3,b_3)$即为L.T.</li><li>首先连接$(a_i,b_j)$，按照顺时针遍历B的链表直到$b_m$，连接$(a_k,b_m)$，同样的，以顺时针遍历直到A的链表直到$a_i$，这样我们就得到了新的Covex Hull</li></ul><h3 id="Finding-Tangents"><a href="#Finding-Tangents" class="headerlink" title="Finding Tangents"></a>Finding Tangents</h3><p>Assume $a_i$ maximizes x within CH(<em>A</em>) $(a_1, a_2,…,a_p)$. $b_1$ minimizes x within CH(<em>B</em>) $(b_1, b_2,…,b_q)$</p><p>$L$ is the vertical line separating <em>A</em> and <em>B</em>. Define $y(i, j)$ as y-coordinate of intersection between <em>L</em> and segment $(a_i, b_j)$</p><p><strong>Claim</strong>: $(a_i,b_j)$ is uppertangent iff it maximizes $y(i, j)$. If $y(i, j)$ is not maximum, there will be points on both sides of $(a_i, b_j)$ and it cannot be a tangent</p><p><strong>Algorithm</strong>: Obvious $O(n^2)$ algorithm looks at all $a_i, b_j$ pairs. $T(n)=2T(n/2)+ Θ(n^2) = Θ(n^2)$</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">i=1, j=1</span><br><span class="line">while (y(i, j + 1) &gt; y(i, j) or y(i − 1, j) &gt; y(i, j))</span><br><span class="line">if (y(i, j + 1) &gt; y(i, j)) -&gt; move right finger clockwise</span><br><span class="line">j = j + 1(mod q)</span><br><span class="line">else</span><br><span class="line">i = i − 1(mod p) -&gt; move left finger anti-clockwise</span><br><span class="line">return (a_i, b_j) as upper tangent</span><br></pre></td></tr></table></figure><h1 id="Median-Finding"><a href="#Median-Finding" class="headerlink" title="Median Finding"></a>Median Finding</h1><p>给定一个有n个数的集合，定义<em>rank(x)</em>为集合中小于等于x的数的数量，找到集合中第$\left\lfloor\frac{n+1}{2}\right\rfloor$大的数(lower median)与第$\left\lceil\frac{n+1}{2}\right\rceil$大的数(upper median). 通过排序来解决这样一个问题是显然的，但时间复杂度会达到$\Theta(n \log n)$，如何优化？</p><h2 id="Select-S-i"><a href="#Select-S-i" class="headerlink" title="Select (S,i)"></a>Select (S,i)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Pick x ∈ S cleverly</span><br><span class="line">Compute k = rank(x)</span><br><span class="line">B = &#123;y ∈ S|y &lt; x&#125;</span><br><span class="line">C = &#123;y ∈ S|y &gt; x&#125;</span><br><span class="line">if k = i</span><br><span class="line">return x</span><br><span class="line">else if k&gt;i</span><br><span class="line">return Select(B, i)</span><br><span class="line">else if k&lt;i</span><br><span class="line">return Select(C, i − k)</span><br></pre></td></tr></table></figure><h2 id="Picking-x-Cleverly"><a href="#Picking-x-Cleverly" class="headerlink" title="Picking x Cleverly"></a>Picking x Cleverly</h2><p>我们需要合理的选取x以防止极端情况出现：</p><ul><li>将集合S分成大小为5的列（$\left\lceil\frac{n}{5}\right\rceil$列）</li><li>对每一列进行排序，时间复杂度为线性</li><li>找到每一列中位数的中位数</li></ul><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/image.4r66tofk6fw0.webp" alt="visual"></p><h3 id="有多少个数是保证大于x的？"><a href="#有多少个数是保证大于x的？" class="headerlink" title="有多少个数是保证大于x的？"></a>有多少个数是保证大于x的？</h3><p>至少一半的$\left\lceil\frac{n}{5}\right\rceil$列都会保证至少有3个数是大于x的，除了x所在的列与少于5个数的列，因此至少有$3(\left\lceil\frac{n}{10}\right\rceil-2)$个数大于x，于是有：</p><script type="math/tex; mode=display">    T(n)=\left\{\begin{array}{ll}O(1), & \text { for } n \leq 140 \\ T\left(\left\lceil\frac{n}{5}\right\rceil\right)+T\left(\frac{7 n}{10}+6\right), \Theta(n), & \text { for } n>140\end{array}\right.</script><p><em>证明递归复杂度过程略</em></p>]]></content>
      
      
      <categories>
          
          <category> 6.046J-2015Sping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> MIT OCW </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数理逻辑读书笔记：归纳与递归</title>
      <link href="/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/"/>
      <url>/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%9A%E5%BD%92%E7%BA%B3%E4%B8%8E%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<iframe src="/myjs/pdfjs/web/viewer.html?file=/pdf/logic.pdf" style='width:100%;height:900px'></iframe>]]></content>
      
      
      <categories>
          
          <category> 数理逻辑 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> A Mathematical Introduction to Logic </tag>
            
            <tag> 坐牢 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lecture 1: Introduction</title>
      <link href="/Lecture-1-Introduction/"/>
      <url>/Lecture-1-Introduction/</url>
      
        <content type="html"><![CDATA[<h1 id="P-amp-NP"><a href="#P-amp-NP" class="headerlink" title="P &amp; NP"></a>P &amp; NP</h1><ul><li><p><strong>P</strong>: class of problems solvable in polynomial time. $O(n^k)$ for some constant $k$. </p><p>Shortest paths in a graph.</p></li><li><p><strong>NP</strong>: class of problems verifiable in polynomial time. </p><p>Verifying a cycle is hamiltonian.</p></li><li><p><strong>NP-complete</strong>: problem is in NP and is as hard as any problem in NP.</p><p>如果NPC问题可在多项式时间内被解决，那么所有的NP问题都可以在多项式时间内被解决</p></li></ul><h1 id="Interval-Scheduling-区间调度问题"><a href="#Interval-Scheduling-区间调度问题" class="headerlink" title="Interval Scheduling / 区间调度问题"></a>Interval Scheduling / 区间调度问题</h1><p>Requests $1,2, . . . , n$, single resource</p><p>$s(i)$ start time, $f(i)$ finish time, $s(i) &lt; f(i)$ (start time must be less than finish time for a request)</p><p>Two requests $i$ and $j$ are compatible if they don’t overlap, i.e., $f(i) \le s(j)$ or $f(j) \le s(i)$.</p><p><img src="https://cdn.jsdelivr.net/gh/shuyuHU328/picx-images-hosting@master/intervalScheduling.5vmv6e5bjes0.png" alt="intervalScheduling" style="zoom:70%;" /></p><p><strong>Goal</strong>: Select a compatible subset of requests of <strong>maximum size</strong>.</p><h2 id="Greedy-Algorithm"><a href="#Greedy-Algorithm" class="headerlink" title="Greedy Algorithm"></a>Greedy Algorithm</h2><p>贪心算法是一种在每一步选择中都采取在当前状态下最好或最优（即最有利）的选择，从而希望导致结果是最好或最优的算法。</p><ol><li>使用某种方法选择一个request $i$.</li><li>拒绝request中冲突的部分</li><li>重复这一步骤直到所有的request被处理</li></ol><h2 id="Rules"><a href="#Rules" class="headerlink" title="Rules"></a>Rules</h2><p><strong>Claim 1.</strong> Greedy algorithm outputs a list of intervals</p><script type="math/tex; mode=display">< s(i_1), f(i_1)>, < s(i_2), f(i_2)>, . . . , < s(i_k), f(i_k) ></script><p>such that</p><script type="math/tex; mode=display">s\left(i_{1}\right)<f\left(i_{1}\right) \leq s\left(i_{2}\right)<f\left(i_{2}\right) \leq \ldots \leq s\left(i_{k}\right)<f\left(i_{k}\right)</script><p><strong>Claim 2.</strong> Given list of intervals $L$, greedy algorithm with <strong>earliest finish time</strong> produces $k^\ast$ intervals, where $k^\ast$ is optimal.</p><p>证明可使用数学归纳法，从$k^\ast=1$的base case归纳，可以得到$k^\ast$一直是最优的序列，详细过程略。</p><h1 id="Weighted-Interval-Scheduling"><a href="#Weighted-Interval-Scheduling" class="headerlink" title="Weighted Interval Scheduling"></a>Weighted Interval Scheduling</h1><p>Each request $i$ has weight $w(i)$. Schedule subset of requests that are non-overlapping with <strong>maximum weight</strong>.</p><p>我们不难发现，在此时贪心算法是失效的，因此我们选择动态规划解决。</p><h2 id="Dynamic-Programming"><a href="#Dynamic-Programming" class="headerlink" title="Dynamic Programming"></a>Dynamic Programming</h2><p><strong>动态规划</strong>（DP）是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p><p>我们这样定义Weighted Interval Scheduling的子问题：</p><script type="math/tex; mode=display">R^{x}=\{j \in R \mid s(j) \geq x\}</script><p>其中，$R$是所有request的集合，如果我们令$x=f(i)$，那么$R^{x}$为集合$R$中起始时间晚于request $i$的request，这样我们需要解决的总子问题数$n=|R|$且只需要计算并记录一次。</p><p>当我们选择request $i$作为序列的起始时，那么剩余的request集合为$R^{f(i)}$，不难注意到有些request与request $i$是协调的，但它仍然不会出现在$R^{f(i)}$中，即我们在按序遍历所有的子问题：</p><script type="math/tex; mode=display">\operatorname{opt}(R)=\max _{1 \leq i \leq n}\left(w(i)+\operatorname{opt}\left(R^{f(i)}\right)\right)</script><p>此时，时间复杂度为$O(n^2)$，这是由于解决每个子问题的时间复杂度为$O(n)$.</p><h2 id="The-nlogn-Dynamic-Programming-Solution"><a href="#The-nlogn-Dynamic-Programming-Solution" class="headerlink" title="The nlogn Dynamic Programming Solution"></a>The nlogn Dynamic Programming Solution</h2><ol><li>将所有requests按结束时间顺序排列</li></ol><script type="math/tex; mode=display">f(1) \le f(2) \le ...\le f(n)</script><ol><li>定义$p(j)$为具有最大下标且不与$j$冲突的request</li><li>定义数组$M[0…n]$为最优解的值组成的数组，$M[k]$为考虑request从1到k所得到的最大权重值</li></ol><p>于是我们可以得到更优的算法：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">M[0] = 0</span><br><span class="line">for j = 1 to n</span><br><span class="line">M[j] = max(w(j)+M[p(j)], M[j-1])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 6.046J-2015Sping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> MIT OCW </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
